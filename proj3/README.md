# Build Your Own World Design Document

**Partner 1:**
Cathy Chao

**Partner 2:**
Lauren Tang

## Classes and Data Structures

### Index.java
Very simple class made to store indices for use in the TETiles array. As outlined in the project 3 
spec, Index(0, 0) corresponds to the bottom-left corner of the world.
* **x** = the "x-coordinate," or the column of the tile's location in the array
* **y** = the "y-coordinate," or the row of the tile's location in the array

### Room.java
Creates a room of random height and length. The method **makeRoom()** takes in the TETiles array and 
updates it by filling in the room in the proper indexes of the array.
* **height** = the height of the room
* **length** = the length of the room
* **bottomLeft** = the Index detailing the bottom-left corner of the room
* **topLeft** = the Index detailing the top-left corner of the room
* **bottomRight** the Index detailing the bottom-right corner of the room
* **topRight** = the Index detailing the top-right corner of the room 

### RandomWorld.java
Contains the entire process for initializing a blank world, using the given seed to create a Random object,
creating the first room to serve as the starting point, and then populating the world sufficiently with enough
rooms and hallways. After each Room object is created, its makeRoom() method is called provided it doesn't violate
the boundary conditions or overlap with other rooms.
* **world** = the TETile array containing all the tiles for the world
* **SEED* = the long value to create the Random object with
* **RANDOM** = the Random object that will be created using SEED

### InteractiveWorld.java
Using RandomWorld as the basis for the random generation of the world, creates the TETile world array and initializes
a pseudorandom location for the player avatar. This class also contains methods that will, depending on the user
input, enable interaction with the world.
* **world** = the TETile array containing all the tiles for the world, generated by RandomWorld. this will be returned
  if activeLOS is false
* **r** = the Random object created from the user-input seed and used to determine the initial avatar location
* **seed** = a long containing the seed that determines the Random object. this will be stored to assist in saving and
  loading the game
* **currentPos** = the Index containing the current location of the avatar
* **dirFacing** = a String detailing which way the avatar is currently facing. by default, the avatar spawns
  facing upwards. even if the avatar cannot currently move in the direction provided, the cone of vision will 
  still change accordingly, so the class's interactivity enables some camera control as well
* **envType** = a String containing the world environment/theme; this will be displayed in the top right corner of the
  HUD at the top of the StdDraw window
* **activeLOS** = a boolean indicating if the LOS-limited version of the world should be provided
* **losWorld** = a TETile[][] array that's a copy of world, but has the LOS constraints enacted; this will be returned
  if activeLOS is true
* **ENVIRONMENTS** = a static final String array dictating the possible environmental themes for InteractiveWorld objects

### Engine.java
This contains the two methods of interaction that are called by Main.java. There are quite a few helper methods, but the 
entire class encapsulates the process of creating an InteractiveWorld object, and altering it based on the user's input,
provided either through keyboard presses or an input string.

## Algorithms
The entire room generation process will ideally consist of something akin to graph traversal: we'll start by randomly
generating one room, then make randomized rooms that connect to each side of the original. Every valid new room
will be added to a LinkedList of rooms that still need to be "visited," so the entire process is like a breadth-
first search, since we want to finish one Room before investigating all of its sides, and then all of its 
subrooms, and so on until the list of rooms is emptied. 

## Persistence
The process of quit/saving and loading is mainly delegated to the Engine class. If a quit/save is requested, Engine
calls the saveContents() method of InteractiveWorld, which returns a String containing the most important components of 
the given world, and writes it to the savedgame.txt file. Upon loading, the contents of savedgame.txt are parsed and given
to the secondary constructor of InteractiveWorld that takes arguments, creating the world exactly as it was when the quit
was requested.